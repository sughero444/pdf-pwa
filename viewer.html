<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PDF Two-Page Viewer â€” scorrimento costante</title>

<style>
  html,body{
    margin:0;
    height:100%;
    background:#000;
    overflow:hidden;
  }
  .controls{
    position:fixed;
    top:12px;
    left:12px;
    z-index:60;
    display:flex;
    gap:8px;
  }
  button{
    background:#222;
    color:#fff;
    padding:8px 10px;
    border-radius:6px;
    cursor:pointer;
    border:1px solid #333;
  }
  .viewer{
    position:fixed;
    inset:0;
    display:block;
    overflow:hidden;
    background:#000;
  }
  .strip{
    height:100%;
    display:flex;
    align-items:stretch;
    box-sizing:border-box;
  }
  .slot{
    flex:0 0 50vw;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    height:100%;
  }
  canvas{
    display:block;
    background:#fff;
    max-height:100vh;
    max-width:50vw;
    width:auto;
    height:100%;
    object-fit:contain;
  }
</style>
</head>
<body>

<div class="controls" id="controls">
  <button id="chooseBtn">Scegli PDF</button>
  <input id="fileInput" type="file" accept="application/pdf" style="display:none">
  <button id="fullscreenBtn" disabled>Schermo intero</button>
</div>

<div class="viewer" id="viewer">
  <div class="strip" id="strip"></div>
</div>

<script src="pdf.js"></script>
<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.js';

const chooseBtn = document.getElementById('chooseBtn');
const fileInput = document.getElementById('fileInput');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const controls = document.getElementById('controls');
const viewer = document.getElementById('viewer');
const strip = document.getElementById('strip');

let pdfDoc = null;
let numPages = 0;
let slotWidth = window.innerWidth / 2;
let leftIndex = 1;
let animating = false;
let animationHandle = null;

const TRANSITION_MS = 12000; 
const QUALITY_SCALE = Math.min(5, Math.max(2, window.devicePixelRatio * 2));

function createSlotElement() {
  const s = document.createElement('div');
  s.className = 'slot';
  return s;
}

/* -------------- RENDER PAGE MIGLIORATO (pagina intera, non zoomata!) ---------------- */

async function renderPageCanvas(pageNum) {
  const page = await pdfDoc.getPage(pageNum);
  const viewport = page.getViewport({ scale: QUALITY_SCALE });

  const canvas = document.createElement('canvas');
  canvas.width = viewport.width;
  canvas.height = viewport.height;

  // Mostra la pagina intera senza zoom ritagliato
  canvas.style.width = "auto";
  canvas.style.height = "100%";
  canvas.style.maxHeight = "100vh";
  canvas.style.maxWidth = "50vw";
  canvas.style.objectFit = "contain";

  const ctx = canvas.getContext('2d');
  await page.render({ canvasContext: ctx, viewport }).promise;

  return canvas;
}

/* --------------------------------------------------------------------------- */

async function buildAllSlots() {
  strip.innerHTML = '';
  slotWidth = Math.round(window.innerWidth / 2);

  strip.appendChild(createSlotElement()); // dummy start

  for (let p = 1; p <= numPages; p++) {
    const slot = createSlotElement();
    const canvas = await renderPageCanvas(p);
    slot.appendChild(canvas);
    strip.appendChild(slot);
  }

  strip.appendChild(createSlotElement()); // dummy end
}

function animateScrollTo(targetScroll, durationMs = TRANSITION_MS) {
  if (animationHandle) cancelAnimationFrame(animationHandle);

  const start = performance.now();
  const from = viewer.scrollLeft;
  const delta = targetScroll - from;

  function step(now) {
    const t = Math.min(1, (now - start) / durationMs);
    viewer.scrollLeft = from + delta * t; // lineare

    if (t < 1) {
      animationHandle = requestAnimationFrame(step);
    } else {
      animating = false;
    }
  }

  animating = true;
  animationHandle = requestAnimationFrame(step);
}

function scrollToLeftIndexInstant(index) {
  const slotIndex = Math.max(1, Math.min(index, numPages));
  viewer.scrollLeft = slotIndex * slotWidth;
  leftIndex = slotIndex;
}

function scrollNext() {
  if (animating || leftIndex >= numPages) return;
  const newIndex = leftIndex + 1;
  animateScrollTo(newIndex * slotWidth, TRANSITION_MS);
  leftIndex = newIndex;
}

function scrollPrev() {
  if (animating || leftIndex <= 1) return;
  scrollToLeftIndexInstant(leftIndex - 1);
}

function onKey(e) {
  if (!pdfDoc) return;
  if (e.key === 'ArrowRight') scrollNext();
  else if (e.key === 'ArrowLeft') scrollPrev();
  else if (e.key === 'Escape' && document.fullscreenElement)
    document.exitFullscreen();
}

chooseBtn.addEventListener('click', () => {
  fileInput.value = '';
  fileInput.click();
});

fileInput.addEventListener('change', async (ev) => {
  const f = ev.target.files && ev.target.files[0];
  if (!f) return;

  try {
    const arrayBuffer = await f.arrayBuffer();
    pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

    numPages = pdfDoc.numPages;
    await buildAllSlots();

    leftIndex = 1;
    viewer.scrollLeft = leftIndex * slotWidth;

    fullscreenBtn.disabled = false;
  } catch (err) {
    console.error('Errore PDF', err);
    alert('Errore nel caricamento del PDF');
  }
});

fullscreenBtn.addEventListener('click', async () => {
  try {
    await document.documentElement.requestFullscreen();
  } catch (err) {
    console.warn('Fullscreen fallito', err);
  }

  controls.style.display = 'none';
  viewer.focus();

  window.addEventListener('keydown', onKey);
});

document.addEventListener('fullscreenchange', () => {
  if (!document.fullscreenElement) {
    window.removeEventListener('keydown', onKey);
    controls.style.display = 'flex';
  }
});

window.addEventListener('resize', async () => {
  if (!pdfDoc) return;
  if (animationHandle) cancelAnimationFrame(animationHandle);

  animating = false;
  slotWidth = Math.round(window.innerWidth / 2);

  await buildAllSlots();
  viewer.scrollLeft = leftIndex * slotWidth;
});
</script>
</body>
</html>
