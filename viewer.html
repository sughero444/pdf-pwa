<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PDF → Video (Two-page scroll)</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,Arial}
  .controls{position:fixed;top:10px;left:10px;z-index:999;display:flex;gap:8px;align-items:center;padding:8px}
  button,input,select{padding:8px;border-radius:6px;border:0;background:#222;color:#fff;cursor:pointer}
  #status{margin-left:8px;font-size:14px}
  #videoWrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000}
  video{max-width:100%;max-height:100%;background:#000;outline:none}
  /* hide native controls overlay when paused on some players */
  video::-webkit-media-controls { display:none !important; }
</style>
</head>
<body>

<div class="controls">
  <input id="fileInput" type="file" accept="application/pdf">
  <label style="display:flex;gap:6px;align-items:center;color:#ddd">
    Ris:
    <select id="resolution">
      <option value="1280x720">1280×720</option>
      <option value="1920x1080" selected>1920×1080</option>
      <option value="3840x2160">3840×2160 (heavy)</option>
    </select>
  </label>
  <label style="color:#ddd">FPS:
    <select id="fps"><option>24</option><option>25</option><option selected>30</option></select>
  </label>
  <button id="generateBtn">Genera Video</button>
  <button id="downloadBtn" style="display:none">Scarica</button>
  <button id="fullscreenPlayBtn" style="display:none">Schermo intero</button>
  <span id="status"></span>
</div>

<div id="videoWrap" style="display:none">
  <video id="player" playsinline></video>
</div>

<script src="pdf.js"></script>
<script>
/*
  PDF -> Video generator (versione corretta)
  - animazione basata su performance.now() per garantire 12s esatti per pagina
  - MediaRecorder su canvas.captureStream
  - player in pausa dopo generazione
  - ArrowRight: play fino al prossimo stepSeconds e pause automatico
  - ArrowLeft: torna indietro di un passo (instant)
*/

pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.js';

const fileInput = document.getElementById('fileInput');
const generateBtn = document.getElementById('generateBtn');
const downloadBtn = document.getElementById('downloadBtn');
const status = document.getElementById('status');
const playerWrap = document.getElementById('videoWrap');
const player = document.getElementById('player');
const resSelect = document.getElementById('resolution');
const fpsSelect = document.getElementById('fps');
const fullscreenPlayBtn = document.getElementById('fullscreenPlayBtn');

let pdfDoc = null;
let pagesCanvas = [];
let pageCount = 0;

// Configurazione
const stepSeconds = 12; // 12 secondi per pagina (sempre)
const pairStride = 1;   // avanzare di 1 pagina (da i|i+1 a i+1|i+2)

function log(s) { status.textContent = s; }

fileInput.addEventListener('change', async (e) => {
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  log('Caricamento PDF...');
  try {
    const buf = await f.arrayBuffer();
    pdfDoc = await pdfjsLib.getDocument({ data: buf }).promise;
    pageCount = pdfDoc.numPages;
    log(`PDF caricato — ${pageCount} pagine`);
  } catch (err) {
    console.error(err);
    alert('Errore nel caricamento del PDF');
  }
});

generateBtn.addEventListener('click', async () => {
  if (!pdfDoc) { alert('Seleziona prima un PDF'); return; }

  // parametri video
  const [videoW, videoH] = resSelect.value.split('x').map(Number);
  const fps = Number(fpsSelect.value);
  const pageW = Math.round(videoW / 2);
  const pageH = videoH;

  generateBtn.disabled = true;
  log('Prerendering pagine (potrebbe richiedere tempo)...');

  // prerendering: render ogni pagina su canvas individuale a alta risoluzione
  pagesCanvas = [];
  // qualità: moltiplichiamo per devicePixelRatio e un fattore di sicurezza
  const dpr = window.devicePixelRatio || 1;
  for (let p = 1; p <= pageCount; p++) {
    log(`Render pagina ${p}/${pageCount} ...`);
    const page = await pdfDoc.getPage(p);
    const vp = page.getViewport({ scale: 1 });
    // scale per adattare la pagina a pageW x pageH (fit)
    const scaleX = pageW / vp.width;
    const scaleY = pageH / vp.height;
    const fitScale = Math.min(scaleX, scaleY);
    // aumentiamo per qualità: * dpr * qualityBoost (1.5)
    const qualityBoost = 1.5;
    const scale = fitScale * dpr * qualityBoost;
    const scaled = page.getViewport({ scale });
    const canvas = document.createElement('canvas');
    canvas.width = Math.round(scaled.width);
    canvas.height = Math.round(scaled.height);
    const ctx = canvas.getContext('2d', { alpha:false });
    await page.render({ canvasContext: ctx, viewport: scaled }).promise;
    pagesCanvas.push({ canvas, naturalW: scaled.width, naturalH: scaled.height });
  }

  log('Prerendering completato. Generazione video...');

  // canvas di registrazione (video)
  const recordCanvas = document.createElement('canvas');
  recordCanvas.width = videoW;
  recordCanvas.height = videoH;
  const rctx = recordCanvas.getContext('2d', { alpha:false });

  // inizializza neri
  rctx.fillStyle = '#000';
  rctx.fillRect(0,0,videoW,videoH);

  const stream = recordCanvas.captureStream(fps);

  // scegli mime
  const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ?
               'video/webm;codecs=vp9' :
               (MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' : 'video/webm');

  const options = { mimeType: mime, videoBitsPerSecond: 6_000_000 }; // 6 Mbps baseline

  let recorder;
  try {
    recorder = new MediaRecorder(stream, options);
  } catch (err) {
    console.error('MediaRecorder init failed', err);
    alert('Impossibile inizializzare il recorder nel browser corrente.');
    generateBtn.disabled = false;
    return;
  }

  const chunks = [];
  recorder.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
  recorder.onerror = (e) => console.error('Recorder error', e);

  const waitForStop = () => new Promise(resolve => recorder.onstop = resolve);

  recorder.start();
  log('Recording avviata...');

  // helper: disegna il frame per un offset globale (in pixel)
  function drawFrameForOffset(offsetX) {
    // offsetX rappresenta quanto abbiamo scorrere da sinistra in pixel (positivo)
    rctx.fillStyle = '#000';
    rctx.fillRect(0,0,videoW,videoH);

    // disegna pagine: pagina k posX = (k-1)*pageW - offsetX
    for (let k = 1; k <= pageCount; k++) {
      const posX = Math.round((k-1) * pageW - offsetX);
      if (posX + pageW < 0 || posX > videoW) continue;
      const pc = pagesCanvas[k-1];
      // draw pc.canvas scaled to pageW x pageH at destX,destY
      rctx.drawImage(pc.canvas, 0, 0, pc.naturalW, pc.naturalH, posX, 0, pageW, pageH);
    }
  }

  // numero transizioni (da pagina 1->2, 2->3, ..., pageCount-1 -> pageCount)
  const totalSteps = Math.max(0, pageCount - 1);

  // loop basato sul tempo (garantisce stepSeconds precisi)
  for (let step = 0; step < totalSteps; step++) {
    const startOffset = step * pageW;
    const endOffset = (step + 1) * pageW;
    const startTime = performance.now();
    // loop finché non raggiungiamo stepSeconds
    while (true) {
      const now = performance.now();
      const elapsed = now - startTime;
      const t = Math.min(1, elapsed / (stepSeconds * 1000)); // 0..1 su base tempo reale
      const offsetX = startOffset + t * (endOffset - startOffset);
      drawFrameForOffset(offsetX);
      // await next paint (non dipendiamo dall'FPS)
      await new Promise(requestAnimationFrame);
      if (t >= 1) break;
    }
  }

  // hold finale (mezza seconda)
  {
    const finalOffset = totalSteps * pageW;
    const holdUntil = performance.now() + 500;
    while (performance.now() < holdUntil) {
      drawFrameForOffset(finalOffset);
      await new Promise(requestAnimationFrame);
    }
  }

  // stop recording e attendi stop
  recorder.stop();
  await waitForStop();

  const blob = new Blob(chunks, { type: mime });
  log('Video pronto — dimensione: ' + Math.round(blob.size / 1024) + ' KB');

  // mostra player (in pausa)
  const url = URL.createObjectURL(blob);
  player.src = url;
  player.controls = false;
  playerWrap.style.display = 'flex';
  downloadBtn.style.display = 'inline';
  fullscreenPlayBtn.style.display = 'inline';
  downloadBtn.onclick = () => {
    const a = document.createElement('a');
    a.href = url;
    a.download = 'pdf_scroll.webm';
    a.click();
  };

  // inizialmente fermo e a 0
  player.pause();
  player.currentTime = 0;

  // playback stepping logic: play until next stepSeconds and pause
  let stepTargetTime = null;
  function onTimeUpdate() {
    if (stepTargetTime !== null && player.currentTime >= stepTargetTime - 0.04) {
      player.pause();
      // snap to exactly targetTime to avoid drift
      player.currentTime = Math.min(player.duration, stepTargetTime);
      stepTargetTime = null;
    }
  }
  player.removeEventListener('timeupdate', onTimeUpdate);
  player.addEventListener('timeupdate', onTimeUpdate);

  // handle keys
  function onKeyHandler(ev) {
    if (playerWrap.style.display === 'none') return;
    if (ev.key === 'ArrowRight') {
      // start play until next segment
      if (!player.paused) return; // already playing
      const currentSeg = Math.floor(player.currentTime / stepSeconds);
      const target = Math.min(player.duration, (currentSeg + 1) * stepSeconds);
      stepTargetTime = target;
      // try to enter fullscreen for best effect (user gesture may be required)
      player.play().catch(err => console.error('play error', err));
    } else if (ev.key === 'ArrowLeft') {
      // go back one step (instant)
      const currentSeg = Math.floor(player.currentTime / stepSeconds);
      const newSeg = Math.max(0, currentSeg - 1);
      player.currentTime = newSeg * stepSeconds;
      player.pause();
    } else if (ev.key === 'Escape') {
      if (document.fullscreenElement) document.exitFullscreen().catch(()=>{});
    }
  }

  window.removeEventListener('keydown', onKeyHandler);
  window.addEventListener('keydown', onKeyHandler);

  // fullscreenPlayBtn: mette il player in fullscreen and keeps paused at start
  fullscreenPlayBtn.onclick = async () => {
    try {
      if (player.requestFullscreen) await player.requestFullscreen();
      else if (player.webkitRequestFullscreen) await player.webkitRequestFullscreen();
    } catch (err) { console.warn(err); }
    // keep paused and at start
    player.pause();
    player.currentTime = 0;
  };

  generateBtn.disabled = false;
  log('Pronto: premi Freccia Destra per avviare 12s di riproduzione (pausa automatica).');
});

</script>
</body>
</html>
