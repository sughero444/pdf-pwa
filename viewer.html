<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PDF â†’ Video (Two-page scroll)</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,Arial}
  .controls{position:fixed;top:10px;left:10px;z-index:999;display:flex;gap:8px;align-items:center;padding:8px}
  button,input,select{padding:8px;border-radius:6px;border:0;background:#222;color:#fff;cursor:pointer}

  /* ðŸ”¹ Aggiunto sfondo per rendere visibili i messaggi anche su video chiari */
  #status{
    margin-left:8px;
    font-size:14px;
    background:rgba(0,0,0,0.6);
    padding:4px 8px;
    border-radius:6px;
  }

  #videoWrap{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#000}
  video{max-width:100%;max-height:100%;background:#000;outline:none}

  /* Rimuove overlay dei controlli in pausa su alcuni browser */
  video::-webkit-media-controls { display:none !important; }
</style>
</head>
<body>

<div class="controls">
  <input id="fileInput" type="file" accept="application/pdf">
  <label style="display:flex;gap:6px;align-items:center;color:#ddd">
    Ris:
    <select id="resolution">
      <option value="1280x720">1280Ã—720</option>
      <option value="1920x1080" selected>1920Ã—1080</option>
      <option value="3840x2160">3840Ã—2160 (heavy)</option>
    </select>
  </label>
  <label style="color:#ddd">FPS:
    <select id="fps"><option>24</option><option>25</option><option selected>30</option></select>
  </label>

  <button id="generateBtn">Genera Video</button>
  <button id="loadVideoBtn">Carica Video</button>
  <input id="videoInput" type="file" accept="video/*" style="display:none">

  <button id="downloadBtn" style="display:none">Scarica</button>

  <!-- AGGIUNTA: Esporta MP4 (compare dopo la generazione) -->
  <button id="exportMP4Btn" style="display:none">Esporta MP4</button>

  <button id="fullscreenPlayBtn" style="display:none">Schermo intero</button>

  <span id="status"></span>
</div>

<div id="videoWrap">
  <video id="player" playsinline></video>
</div>

<script src="pdf.js"></script>
<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.js';

const fileInput = document.getElementById('fileInput');
const videoInput = document.getElementById('videoInput');
const loadVideoBtn = document.getElementById('loadVideoBtn');
const generateBtn = document.getElementById('generateBtn');
const downloadBtn = document.getElementById('downloadBtn');
const exportMP4Btn = document.getElementById('exportMP4Btn'); // nuovo
const fullscreenPlayBtn = document.getElementById('fullscreenPlayBtn');
const status = document.getElementById('status');
const playerWrap = document.getElementById('videoWrap');
const player = document.getElementById('player');
const resSelect = document.getElementById('resolution');
const fpsSelect = document.getElementById('fps');
  
let pdfFileName = 'pdf_scroll'; // default
let pdfDoc = null;
let pagesCanvas = [];
let pageCount = 0;

const stepSeconds = 12;
const pairStride = 1;

function log(s){ status.textContent = s; }

/* keep latest generated webm for conversion */
let latestWebmBlob = null;
let latestWebmUrl = null;

/* ---- Carica PDF ---- */
fileInput.addEventListener('change', async e=>{
  const f = e.target.files[0];
  if (!f) return;
  pdfFileName = (f.name || 'pdf_scroll').replace(/\.[^/.]+$/, ""); // rimuove estensione .pdf

  log('Caricamento PDF...');
  try{
    const buf = await f.arrayBuffer();
    pdfDoc = await pdfjsLib.getDocument({data:buf}).promise;
    pageCount = pdfDoc.numPages;
    log(`PDF caricato â€” ${pageCount} pagine`);
  }catch(err){
    console.error(err);
    alert('Errore nel caricamento del PDF');
  }
});

/* ---- Carica VIDEO ---- */
loadVideoBtn.addEventListener('click', ()=> videoInput.click());

videoInput.addEventListener('change', e=>{
  const f = e.target.files[0];
  if(!f) return;

  const url = URL.createObjectURL(f);
  player.src = url;
  player.controls = false;

  playerWrap.style.display = 'flex';
  fullscreenPlayBtn.style.display = 'inline';
  downloadBtn.style.display = 'none';
  exportMP4Btn.style.display = 'none';

  player.pause();
  player.currentTime = 0;

  log('Video caricato â€” pronto per la riproduzione');

  /* ---------------------------------------------------------
     FULLSCREEN identico ai video generati
  --------------------------------------------------------- */
  fullscreenPlayBtn.onclick = async ()=>{
    try{
      if(player.requestFullscreen) await player.requestFullscreen();
      else if(player.webkitRequestFullscreen) await player.webkitRequestFullscreen();
    }catch(err){}

    player.pause();
    player.currentTime = 0;
  };

  /* ---------------------------------------------------------
     ðŸ”¥ AGGIUNTO: motore di avanzamento identico ai video generati
     (Freccia Destra = avanza 12s + stop automatico)
  --------------------------------------------------------- */
  let stepTargetTime = null;

  function onTimeUpdate(){
    if(stepTargetTime!==null && player.currentTime >= stepTargetTime - 0.04){
      player.pause();
      player.currentTime = Math.min(player.duration, stepTargetTime);
      stepTargetTime = null;
    }
  }

  player.removeEventListener('timeupdate', onTimeUpdate);
  player.addEventListener('timeupdate', onTimeUpdate);

  function onKey(ev){
    if(playerWrap.style.display==='none') return;

    if(ev.key==='ArrowRight'){
      if(!player.paused) return;
      const currentSeg = Math.floor(player.currentTime / stepSeconds);
      stepTargetTime = Math.min(player.duration, (currentSeg+1)*stepSeconds);
      player.play().catch(()=>{});
    }
    else if(ev.key==='ArrowLeft'){
      const currentSeg = Math.floor(player.currentTime / stepSeconds);
      player.currentTime = Math.max(0, (currentSeg-1)*stepSeconds);
      player.pause();
    }
    else if(ev.key==='Escape'){
      if(document.fullscreenElement) document.exitFullscreen();
    }
  }

  window.removeEventListener('keydown', onKey);
  window.addEventListener('keydown', onKey);
});


/* ---- GENERATORE VIDEO PDF ---- */
/* (IMPORTANTE: identico alla tua versione funzionante, senza modifiche!) */

generateBtn.addEventListener('click', async () => {
  if (!pdfDoc) { alert('Seleziona prima un PDF'); return; }

  const [videoW, videoH] = resSelect.value.split('x').map(Number);
  const fps = Number(fpsSelect.value);
  const pageW = Math.round(videoW / 2);
  const pageH = videoH;

  generateBtn.disabled = true;
  log('Prerendering pagine (potrebbe richiedere tempo)...');

  pagesCanvas = [];
  const dpr = window.devicePixelRatio || 1;

  for (let p = 1; p <= pageCount; p++) {
    log(`Render pagina ${p}/${pageCount} ...`);
    const page = await pdfDoc.getPage(p);
    const vp = page.getViewport({ scale: 1 });

    const scaleX = pageW / vp.width;
    const scaleY = pageH / vp.height;
    const fitScale = Math.min(scaleX, scaleY);
    const qualityBoost = 1.5;
    const scale = fitScale * dpr * qualityBoost;

    const scaled = page.getViewport({ scale });
    const canvas = document.createElement('canvas');
    canvas.width = Math.round(scaled.width);
    canvas.height = Math.round(scaled.height);
    const ctx = canvas.getContext('2d', { alpha:false });
    await page.render({ canvasContext: ctx, viewport: scaled }).promise;
    pagesCanvas.push({ canvas, naturalW: scaled.width, naturalH: scaled.height });
  }

  log('Prerendering completato. Generazione video...');

  const recordCanvas = document.createElement('canvas');
  recordCanvas.width = videoW;
  recordCanvas.height = videoH;
  const rctx = recordCanvas.getContext('2d', { alpha:false });

  rctx.fillStyle = '#000';
  rctx.fillRect(0,0,videoW,videoH);

  const stream = recordCanvas.captureStream(fps);

  const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9')
    ? 'video/webm;codecs=vp9'
    : (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')
      ? 'video/webm;codecs=vp8'
      : 'video/webm');

  const options = { mimeType: mime, videoBitsPerSecond: 6_000_000 };

  let recorder;
  try { recorder = new MediaRecorder(stream, options); }
  catch(err){
    alert('Impossibile inizializzare il recorder');
    generateBtn.disabled = false;
    return;
  }

  const chunks = [];
  recorder.ondataavailable = e=>{ if(e.data.size) chunks.push(e.data); };
  const waitForStop = ()=> new Promise(r=>recorder.onstop = r);

  recorder.start();
  log('Recording avviata...');

  function drawFrameForOffset(offsetX){
    rctx.fillStyle = '#000';
    rctx.fillRect(0,0,videoW,videoH);
    for(let k=1;k<=pageCount;k++){
      const posX = Math.round((k-1)*pageW - offsetX);
      if(posX + pageW < 0 || posX > videoW) continue;
      const pc = pagesCanvas[k-1];
      rctx.drawImage(pc.canvas,0,0,pc.naturalW,pc.naturalH,posX,0,pageW,pageH);
    }
  }

  const totalSteps = Math.max(0,pageCount-1);

  for(let step=0; step<totalSteps; step++){
    const startOffset = step*pageW;
    const endOffset   = (step+1)*pageW;
    const startTime   = performance.now();

    while(true){
      const now = performance.now();
      const elapsed = now - startTime;
      const t = Math.min(1, elapsed/(stepSeconds*1000));
      const offsetX = startOffset + t*(endOffset-startOffset);
      drawFrameForOffset(offsetX);
      await new Promise(requestAnimationFrame);
      if(t>=1) break;
    }
  }

  {
    const finalOffset = totalSteps*pageW;
    const holdUntil = performance.now() + 500;
    while(performance.now() < holdUntil){
      drawFrameForOffset(finalOffset);
      await new Promise(requestAnimationFrame);
    }
  }

  recorder.stop();
  await waitForStop();

  const blob = new Blob(chunks,{type:mime});
  log('Video pronto');

  const url = URL.createObjectURL(blob);
  player.src = url;
  player.controls = false;
  playerWrap.style.display = 'flex';
  downloadBtn.style.display = 'inline';
  fullscreenPlayBtn.style.display = 'inline';

  // save latest webm for conversion
  latestWebmBlob = blob;
  latestWebmUrl = url;

  downloadBtn.onclick = ()=>{
    const a = document.createElement('a');
    a.href = url;
    a.download = pdfFileName + '.webm';
    a.click();
  };

  player.pause();
  player.currentTime = 0;

  let stepTargetTime = null;
  function onTimeUpdate(){
    if(stepTargetTime!==null && player.currentTime >= stepTargetTime - 0.04){
      player.pause();
      player.currentTime = Math.min(player.duration, stepTargetTime);
      stepTargetTime = null;
    }
  }
  player.removeEventListener('timeupdate',onTimeUpdate);
  player.addEventListener('timeupdate',onTimeUpdate);

  function onKey(ev){
    if(playerWrap.style.display==='none') return;
    if(ev.key==='ArrowRight'){
      if(!player.paused) return;
      const currentSeg = Math.floor(player.currentTime/stepSeconds);
      stepTargetTime = Math.min(player.duration,(currentSeg+1)*stepSeconds);
      player.play().catch(()=>{});
    }else if(ev.key==='ArrowLeft'){
      const currentSeg = Math.floor(player.currentTime/stepSeconds);
      player.currentTime = Math.max(0,(currentSeg-1)*stepSeconds);
      player.pause();
    }else if(ev.key==='Escape'){
      if(document.fullscreenElement) document.exitFullscreen();
    }
  }
  window.removeEventListener('keydown',onKey);
  window.addEventListener('keydown',onKey);

  fullscreenPlayBtn.onclick = async ()=>{
    try{
      if(player.requestFullscreen) await player.requestFullscreen();
      else if(player.webkitRequestFullscreen) await player.webkitRequestFullscreen();
    }catch(err){}
    player.pause();
    player.currentTime = 0;
  };

  // show convert button after successful generation
  exportMP4Btn.style.display = 'inline';

  generateBtn.disabled = false;
  log("Pronto. Freccia Destra = avanza di 12s, Freccia Sinistra = torna indietro.");
});

/* ---------------------------------------------------
   EXPORT MP4 (hardware) - AGGIUNTA
   - eseguita ON DEMAND quando premi exportMP4Btn
----------------------------------------------------*/
exportMP4Btn.addEventListener('click', async () => {
  if (!latestWebmBlob) { alert('Nessun video generato da convertire.'); return; }
  exportMP4Btn.disabled = true;
  log('Preparazione conversione in MP4 (hardware)...');

  // create a temporary video element to play the webm
  const tmp = document.createElement('video');
  tmp.muted = true; // allow autoplay in many browsers
  tmp.playsInline = true;
  tmp.src = latestWebmUrl;

  // wait for metadata so duration is known
  await new Promise((res, rej) => {
    const t = setTimeout(() => rej(new Error('timeout loading media')), 10000);
    tmp.addEventListener('loadedmetadata', () => { clearTimeout(t); res(); }, { once: true });
    tmp.addEventListener('error', (e) => { clearTimeout(t); rej(new Error('errore caricamento media')); }, { once: true });
  }).catch(err => {
    console.error('load metadata error', err);
    alert('Impossibile caricare il video temporaneo per la conversione.');
    exportMP4Btn.disabled = false;
    log('');
    return;
  });

  // attempt to find an MP4 mime the browser supports for MediaRecorder
  const candidates = [
    'video/mp4;codecs="avc1.42E01E"',
    'video/mp4;codecs="avc1.4d401e"',
    'video/mp4'
  ];
  let chosen = null;
  for (const c of candidates) {
    try {
      if (MediaRecorder.isTypeSupported(c)) { chosen = c; break; }
    } catch(e){}
  }

  if (!chosen) {
    alert('Questo browser non supporta l\'encoding MP4 via MediaRecorder. Se necessario posso usare ffmpeg.wasm (ma richiede CORP/COOP headers) o puoi fare mirroring dello schermo.');
    exportMP4Btn.disabled = false;
    log('');
    return;
  }

  log('Formato MP4 supportato: ' + chosen + ' â€” registrazione in corso...');

  // capture stream from the tmp video
  const stream = tmp.captureStream ? tmp.captureStream() : null;
  if (!stream) {
    alert('captureStream non supportato in questo browser.');
    exportMP4Btn.disabled = false;
    log('');
    return;
  }

  let recorder;
  try {
    recorder = new MediaRecorder(stream, { mimeType: chosen, videoBitsPerSecond: 6_000_000 });
  } catch (err) {
    console.error('MediaRecorder init failed for mp4', err);
    alert('Impossibile inizializzare il recorder MP4 in questo browser.');
    exportMP4Btn.disabled = false;
    log('');
    return;
  }

  const parts = [];
  recorder.ondataavailable = (e) => { if (e.data && e.data.size) parts.push(e.data); };
  recorder.onerror = (e) => console.error('recorder mp4 error', e);

  // start recorder, play the tmp video all the way through
  recorder.start();

  // in some browsers we need to call play() as a user gesture; we're inside a click handler so OK
  try {
    await tmp.play();
  } catch(e){
    // if autoplay prevented, try again after small delay
    try { tmp.muted = true; await tmp.play(); } catch(e2) {}
  }

  // stop recorder when video ends (or after duration)
  await new Promise((resolve) => {
    tmp.addEventListener('ended', () => {
      // give recorder a small moment to flush
      setTimeout(() => {
        try { recorder.stop(); } catch(e){}
      }, 200);
    }, { once: true });

    recorder.onstop = () => resolve();
    // safety: also stop after tmp.duration + 1s if 'ended' didn't fire
    setTimeout(() => {
      try { recorder.state !== 'inactive' && recorder.stop(); } catch(e){}
    }, (tmp.duration + 1) * 1000);
  });

  // build mp4 blob
  const mp4Blob = new Blob(parts, { type: chosen });
  const mp4Url = URL.createObjectURL(mp4Blob);

  // offer download with same base name as PDF
  const a = document.createElement('a');
  a.href = mp4Url;
  a.download = pdfFileName + '.mp4';
  a.click();

  // also load mp4 into player (keeping stepping behavior)
  player.src = mp4Url;
  player.controls = false;
  player.pause();
  player.currentTime = 0;
  playerWrap.style.display = 'flex';
  fullscreenPlayBtn.style.display = 'inline';
  downloadBtn.style.display = 'inline';

  // allow re-export after finishing
  exportMP4Btn.disabled = false;
  log('MP4 pronto e caricato nel player (puoi scaricarlo o riprodurlo).');
});

</script>
</body>
</html>
