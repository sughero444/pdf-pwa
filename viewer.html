<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PDF Two-Page Viewer â€” scorrimento costante</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#000000">

<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  .controls{position:fixed;top:12px;left:12px;z-index:60;display:flex;gap:8px}
  button{background:#222;color:#fff;padding:8px 10px;border-radius:6px;cursor:pointer;border:1px solid #333}
  .viewer{position:fixed;inset:0;display:block;overflow:hidden;background:#000}
  .strip{height:100%;display:flex;align-items:stretch;box-sizing:border-box}
  .slot{flex:0 0 50vw;display:flex;align-items:center;justify-content:center;overflow:hidden;height:100%}
  canvas{display:block;max-height:100vh;width:auto;height:auto;background:#fff}
</style>
</head>
<body>

<div class="controls" id="controls">
  <button id="chooseBtn">Scegli PDF</button>
  <input id="fileInput" type="file" accept="application/pdf" style="display:none">
  <button id="fullscreenBtn" disabled>Schermo intero</button>
</div>

<div class="viewer" id="viewer">
  <div class="strip" id="strip"></div>
</div>

<script src="pdf.js"></script>
<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.js';

const chooseBtn = document.getElementById('chooseBtn');
const fileInput = document.getElementById('fileInput');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const controls = document.getElementById('controls');

const viewer = document.getElementById('viewer');
const strip = document.getElementById('strip');

let pdfDoc = null;
let numPages = 0;
let slotWidth = window.innerWidth / 2;
let leftIndex = 1;
let animating = false;
let animationHandle = null;
const TRANSITION_MS = 12000; // 12 secondi


/* -----------------------------------------------------------
   ðŸ”¥ HIDPI CAST BOOST
   Rileva automaticamente quando l'output Ã¨ su uno schermo enorme
------------------------------------------------------------ */

function computeQualityScale() {
  const w = window.screen.width;
  const h = window.screen.height;
  const dpr = window.devicePixelRatio || 1;

  // Risoluzione reale in pixel
  const totalPixels = w * h * dpr * dpr;

  // Soglia per capire se siamo su uno schermo tipo TV 4K
  const isLargeDisplay = totalPixels > 4_000_000; // > ~FullHD

  if (isLargeDisplay) {
    // Massima qualitÃ : super nitida su TV
    return 4.0;
  } else {
    // Telefono o laptop
    return Math.min(3, Math.max(1.5, dpr * 1.5));
  }
}

let QUALITY_SCALE = computeQualityScale();


/* -----------------------------------------------------------
   Rendering pagine
------------------------------------------------------------ */

function createSlotElement() {
  const s = document.createElement('div');
  s.className = 'slot';
  return s;
}

async function renderPageCanvas(pageNum) {
  const page = await pdfDoc.getPage(pageNum);
  const viewport = page.getViewport({ scale: 1 });

  // Risoluzione target basata sul nuovo QUALITY_SCALE
  const targetWidth = viewport.width * QUALITY_SCALE;
  const targetHeight = viewport.height * QUALITY_SCALE;

  const ratio = viewport.width / viewport.height;

  let finalWidth = targetWidth;
  let finalHeight = finalWidth / ratio;

  if (finalHeight > targetHeight) {
    finalHeight = targetHeight;
    finalWidth = finalHeight * ratio;
  }

  const scale = finalWidth / viewport.width;
  const scaled = page.getViewport({ scale });

  const canvas = document.createElement('canvas');
  canvas.style.width = scaled.width / window.devicePixelRatio + "px";
  canvas.style.height = scaled.height / window.devicePixelRatio + "px";

  canvas.width = Math.round(scaled.width);
  canvas.height = Math.round(scaled.height);

  const ctx = canvas.getContext('2d');
  await page.render({ canvasContext: ctx, viewport: scaled }).promise;

  return canvas;
}

async function buildAllSlots() {
  strip.innerHTML = '';
  slotWidth = Math.round(window.innerWidth / 2);
  strip.appendChild(createSlotElement()); // dummy start

  for (let p = 1; p <= numPages; p++) {
    const slot = createSlotElement();
    const canvas = await renderPageCanvas(p);
    slot.appendChild(canvas);
    strip.appendChild(slot);
  }

  strip.appendChild(createSlotElement()); // dummy end
}


/* -----------------------------------------------------------
   Scorrimento pagine
------------------------------------------------------------ */

function animateScrollTo(targetScroll, durationMs = TRANSITION_MS) {
  if (animationHandle) cancelAnimationFrame(animationHandle);
  const start = performance.now();
  const from = viewer.scrollLeft;
  const delta = targetScroll - from;

  function step(now) {
    const t = Math.min(1, (now - start) / durationMs);
    viewer.scrollLeft = from + delta * t;
    if (t < 1) animationHandle = requestAnimationFrame(step);
    else animating = false;
  }

  animating = true;
  animationHandle = requestAnimationFrame(step);
}

function scrollToLeftIndexInstant(index) {
  const slotIndex = Math.max(1, Math.min(index, numPages));
  viewer.scrollLeft = slotIndex * slotWidth;
  leftIndex = slotIndex;
}

function scrollNext() {
  if (animating || leftIndex >= numPages) return;
  const newIndex = leftIndex + 1;
  animateScrollTo(newIndex * slotWidth, TRANSITION_MS);
  leftIndex = newIndex;
}

function scrollPrev() {
  if (animating || leftIndex <= 1) return;
  scrollToLeftIndexInstant(leftIndex - 1);
}

function onKey(e) {
  if (!pdfDoc) return;
  if (e.key === 'ArrowRight') scrollNext();
  else if (e.key === 'ArrowLeft') scrollPrev();
  else if (e.key === 'Escape' && document.fullscreenElement) document.exitFullscreen();
}


/* -----------------------------------------------------------
   Caricamento PDF
------------------------------------------------------------ */

chooseBtn.addEventListener('click', () => { 
  fileInput.value = ''; 
  fileInput.click(); 
});

fileInput.addEventListener('change', async (ev) => {
  const f = ev.target.files && ev.target.files[0];
  if (!f) return;

  try {
    const buffer = await f.arrayBuffer();
    pdfDoc = await pdfjsLib.getDocument({ data: buffer }).promise;

    numPages = pdfDoc.numPages;
    QUALITY_SCALE = computeQualityScale(); // ðŸ”¥ Ricalcolo qualitÃ  al volo
    await buildAllSlots();

    leftIndex = 1;
    viewer.scrollLeft = leftIndex * slotWidth;
    fullscreenBtn.disabled = false;

  } catch (err) {
    console.error('Errore caricamento PDF', err);
    alert('Errore nel caricamento del PDF');
  }
});


/* -----------------------------------------------------------
   Fullscreen
------------------------------------------------------------ */

fullscreenBtn.addEventListener('click', async () => {
  try {
    const docEl = document.documentElement;
    await (docEl.requestFullscreen || docEl.webkitRequestFullscreen).call(docEl);
  } catch (err) {
    console.warn('Impossibile entrare in fullscreen', err);
    return;
  }

  controls.style.display = 'none';
  viewer.tabIndex = -1;
  viewer.focus();
  window.addEventListener('keydown', onKey);
});

document.addEventListener('fullscreenchange', () => {
  if (!document.fullscreenElement) {
    window.removeEventListener('keydown', onKey);
    controls.style.display = 'flex';
  }
});


/* -----------------------------------------------------------
   Resize
------------------------------------------------------------ */

window.addEventListener('resize', async () => {
  if (!pdfDoc) return;
  if (animationHandle) cancelAnimationFrame(animationHandle);
  animating = false;

  QUALITY_SCALE = computeQualityScale(); // ðŸ”¥ Si adatta alla nuova risoluzione
  slotWidth = Math.round(window.innerWidth / 2);

  await buildAllSlots();
  viewer.scrollLeft = leftIndex * slotWidth;
});
</script>

<script>
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("service-worker.js");
}
</script>

</body>
</html>
